#! /usr/bin/env python3

import argparse
import glob
import os
import subprocess
import tempfile

from oclintscripts import environment
from oclintscripts import path
from oclintscripts import process

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('-clean', '--clean', action="store_true")
arg_parser.add_argument('-skip-convert', '--skip-convert', action="store_true",
                        help="Skip converting bitcode to native objects")
args = arg_parser.parse_args()

def clean_module():
    build_path = path.build.clang_build_dir
    path.rm_f(build_path)
    install_dir = path.build.clang_install_dir
    path.rm_f(install_dir)

def is_bitcode(filepath):
    """Check if a file is LLVM bitcode by reading magic bytes."""
    try:
        with open(filepath, 'rb') as f:
            magic = f.read(4)
            # Traditional LLVM bitcode magic: 0x42 0x43 0xc0 0xde ('BC\xc0\xde')
            # Also check for bitcode wrapper
            return magic == b'BC\xc0\xde' or magic[:2] == b'BC'
    except:
        return False

def find_llc(install_path):
    """Find llc binary, checking multiple locations."""
    # First check in the prebuilt LLVM directory
    llc_bin = os.path.join(install_path, 'bin', 'llc')
    if os.path.exists(llc_bin):
        return llc_bin

    # Check in PATH
    import shutil
    llc_in_path = shutil.which('llc')
    if llc_in_path:
        return llc_in_path

    # Check Homebrew LLVM locations on macOS
    if environment.is_darwin():
        homebrew_paths = [
            '/opt/homebrew/opt/llvm@21/bin/llc',
            '/opt/homebrew/opt/llvm/bin/llc',
            '/usr/local/opt/llvm@21/bin/llc',
            '/usr/local/opt/llvm/bin/llc',
        ]
        for path in homebrew_paths:
            if os.path.exists(path):
                return path

    return None

def convert_bitcode_libraries(install_path):
    """Convert bitcode in static libraries to native object files."""
    lib_dir = os.path.join(install_path, 'lib')
    llc_bin = find_llc(install_path)

    print(f"Looking for llc in: {install_path}/bin/llc")
    if llc_bin:
        print(f"Found llc at: {llc_bin}")
    else:
        print("Warning: llc not found, skipping bitcode conversion")
        print("Note: On macOS, this may cause linking errors with prebuilt LLVM libraries")
        return

    # Find all static libraries
    libraries = []
    for pattern in ['libclang*.a', 'libLLVM*.a']:
        libraries.extend(glob.glob(os.path.join(lib_dir, pattern)))

    print(f"Found {len(libraries)} static libraries to check for bitcode")

    total_converted = 0
    for lib_path in libraries:
        with tempfile.TemporaryDirectory() as tmpdir:
            # Extract library
            result = subprocess.run(['ar', 'x', lib_path], cwd=tmpdir, capture_output=True)
            if result.returncode != 0:
                print(f"Warning: Failed to extract {lib_path}")
                continue

            # Get list of object files
            obj_files = glob.glob(os.path.join(tmpdir, '*.o'))
            converted_count = 0
            bitcode_count = 0

            for obj_file in obj_files:
                if is_bitcode(obj_file):
                    bitcode_count += 1
                    # Convert bitcode to native object with PIC relocation model
                    # required for linking into shared libraries
                    native_obj = obj_file + '.native'
                    result = subprocess.run(
                        [llc_bin, '-filetype=obj', '-relocation-model=pic', obj_file, '-o', native_obj],
                        capture_output=True
                    )
                    if result.returncode == 0:
                        os.replace(native_obj, obj_file)
                        converted_count += 1
                    else:
                        print(f"Failed to convert {os.path.basename(obj_file)}: {result.stderr.decode()}")

            if converted_count > 0:
                obj_files = glob.glob(os.path.join(tmpdir, '*.o'))
                backup_path = lib_path + '.bc_backup'
                os.rename(lib_path, backup_path)
                result = subprocess.run(
                    ['ar', 'r', lib_path] + [os.path.basename(f) for f in obj_files],
                    cwd=tmpdir, capture_output=True
                )
                if result.returncode == 0:
                    os.remove(backup_path)
                    print(f"Converted {converted_count}/{bitcode_count} bitcode files in {os.path.basename(lib_path)}")
                    total_converted += converted_count
                else:
                    os.rename(backup_path, lib_path)
                    print(f"Failed to repack {lib_path}: {result.stderr.decode()}")

    print(f"Total bitcode objects converted: {total_converted}")

def setup_prebuilt_binary():
    build_path = path.build.clang_build_dir
    install_path = path.build.clang_install_dir

    if environment.is_darwin():
        binary_url = path.url.clang_prebuilt_binary_for_macos_arm64
    else:
        if environment.is_aarch64_or_arm64():
            binary_url = path.url.clang_prebuilt_binary_for_ubuntu_aarch64
        else:
            binary_url = path.url.clang_prebuilt_binary_for_ubuntu_amd64

    current_dir = os.getcwd()
    path.mkdir_p(build_path)
    path.cd(build_path)
    process.call('curl -L -o prebuilt.tar.xz ' + binary_url)
    path.mkdir_p(install_path)
    process.call('tar xf prebuilt.tar.xz -C ' + install_path + ' --strip-components=1')

    # Convert bitcode in static libraries to native objects
    if not args.skip_convert:
        convert_bitcode_libraries(install_path)

    path.cd(current_dir)

if args.clean:
    clean_module()
setup_prebuilt_binary()
